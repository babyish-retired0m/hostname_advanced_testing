#!/usr/bin/env python3
__version__ = "1.1"
"""
	icmplib
	The power to forge ICMP packets and do ping and traceroute.
		https://github.com/ValentinBELYN/icmplib
	:copyright: Copyright 2017-2022 Valentin BELYN.
	:license: GNU LGPLv3, see the LICENSE for details.
"""
from socket import getfqdn
from time import sleep
try:
	from icmplib import ICMPv4Socket, ICMPv6Socket, ICMPRequest
	from icmplib import ICMPLibError, TimeoutExceeded, TimeExceeded
	from icmplib import PID, resolve, is_hostname, is_ipv6_address
except ImportError:
	raise SystemExit("Please install icmplib, pip3 install icmplib, https://github.com/ValentinBELYN/icmplib")

def verbose_traceroute(address, count=2, interval=0.05, timeout=0.20,
		id=PID, max_hops=30):
	#interval=0.05, timeout=0.10,
	#timeout=2
	#count=2, interval=0.05, timeout=0.20, id=PID, max_hops=30
	
	def getpcname():
		from os import environ
		from platform import node
		from socket import gethostname
		n1 = node()
		n2 = gethostname()
		n3 = environ.get("COMPUTERNAME")
		if n1 == n2 == n3:
			pcname = n1
		elif n1 == n2:
			pcname = n1
		elif n1 == n3:
			pcname = n1
		elif n2 == n3:
			pcname = n2
		else:
			raise Exception("Computernames are not equal to each other")
		if pcname.endswith('.local'): return pcname[:pcname.find('.local')]
		else: return pcname
	def getusername():
		from os import getlogin
		from getpass import getuser
		n1=getlogin()
		n2=getuser()
		if n1 == n2: user = n1
		elif n2 == 'root': user = n1
		else: raise Exception("Username are not equal to each other")
		return user
	def getcurrentdirectory():
		from os import getcwd,path
		n1=getcwd() 
		n2=path.expanduser('~')
		if n1 == n2: return '~'
		else: return n1
	
	results = {}
	# We perform a DNS lookup if a hostname or an FQDN is passed in
	# parameters.
	if is_hostname(address):
		ip_address = resolve(address)[0]
	else:
		ip_address = address
	results[address]={}
	# A payload of 56 bytes is used by default. You can modify it using
	# the 'payload_size' parameter of your ICMP request.
	payload_size=56
	if interval==0.05: print_interval=500
	else: print_interval=500
	if timeout==0.20: print_timeout=1
	else: print_timeout=1
	print(f'{getusername()}@{getpcname()} {getcurrentdirectory()}$ traceroute -m {max_hops} -w {print_timeout} -z {print_interval} {address} {payload_size}')
	print(f'traceroute to {address} ({ip_address}), '
		  f'{max_hops} hops max, {payload_size} byte packets')
	results[address]['traceroute']=[]
	results[address]['parameters']={"address":address, "ip_address":ip_address,"max_hops":max_hops, "timeout":print_timeout, "interval":print_interval, "payload_size":payload_size, "username":getusername(), "pcname":getpcname(), "currentdirectory":getcurrentdirectory()}
	#results[address]['traceroute'].append(f'Traceroute to {address} ({ip_address}), {max_hops} hops max, {payload_size} byte packets')

	# We detect the socket to use from the specified IP address
	if is_ipv6_address(ip_address):
		sock = ICMPv6Socket()
	else:
		sock = ICMPv4Socket()

	ttl = 1
	host_reached = False

	while not host_reached and ttl <= max_hops:
		for sequence in range(count):
			# We create an ICMP request
			request = ICMPRequest(
				destination=ip_address,
				id=id,
				sequence=sequence,
				ttl=ttl,
				payload_size=payload_size)

			try:
				# We send the request
				sock.send(request)

				# We are awaiting receipt of an ICMP reply
				reply = sock.receive(request, timeout)

				# We received a reply
				# We display some information
				source_name = getfqdn(reply.source)
				if ttl<10:
					print(f' {ttl:<2} {source_name}  ({reply.source})  ', end='')
				else:
					print(f'{ttl:<2}  {source_name}  ({reply.source})  ', end='')
				# We throw an exception if it is an ICMP error message
				reply.raise_for_status()

				# We reached the destination host
				# We calculate the round-trip time and we display it
				round_trip_time = (reply.time - request.time) * 1000
				print(round(round_trip_time, 3), 'ms')
				results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))+' ms'])

				# We can stop the search
				host_reached = True
				break

			except TimeExceeded as err:
				# An ICMP Time Exceeded message has been received
				# The message was probably generated by an intermediate
				# gateway
				reply = err.reply

				# We calculate the round-trip time and we display it
				round_trip_time = (reply.time - request.time) * 1000
				print(round(round_trip_time, 3), 'ms')
				#results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))'+' ms'])
				results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))+' ms'])
				sleep(interval)
				break

			except TimeoutExceeded:
				# The timeout has been reached and no host or gateway
				# has responded after multiple attempts
				if sequence >= count - 1:
					#print(f'{ttl:<2}  * * *')
					if ttl<10:
						print(f' {ttl:<2} * * *')
					else:
						print(f'{ttl:<2}  * * *')
					results[address]['traceroute'].append(None)
			except ICMPLibError:
				# Other errors are ignored
				pass

		ttl += 1
	print('Completed.')
	if host_reached: print(f'Host {ip_address} ({address}) reached')
	else: print('Host did not reach')
	results[address]['completed'] = True
	results[address]['host_reached'] = host_reached
		
	return results

# This function supports both FQDNs and IP addresses. See the 'resolve'
# function for details.
if __name__ == '__main__':
	import sys
	if len(sys.argv) != 2:
		print('usage: %s example.com' % sys.argv[0])
		host='fbi.gov'
	else:
		host=str(sys.argv[1])
		print(sys.argv[1])
	result=verbose_traceroute(host)
	print('result',result)
	result=verbose_traceroute("ic3.gov")
	print('result',result)