#!/usr/bin/env python3
__version__ = "1.2"
"""
	icmplib
	The power to forge ICMP packets and do ping and traceroute.
		https://github.com/ValentinBELYN/icmplib
	:copyright: Copyright 2017-2022 Valentin BELYN.
	:license: GNU LGPLv3, see the LICENSE for details.
"""
from socket import getfqdn
from time import sleep
import sys
try:
	from icmplib import ICMPv4Socket, ICMPv6Socket, ICMPRequest
	from icmplib import ICMPLibError, TimeoutExceeded, TimeExceeded
	from icmplib import PID, resolve, is_hostname, is_ipv6_address
except ImportError:
	raise SystemExit("Please install icmplib, pip3 install icmplib, https://github.com/ValentinBELYN/icmplib")
if __name__ != '__main__':
	import utilities.utility as utility
else:
	import utility

def verbose_traceroute(address, count=2, interval=0.05, timeout=0.01,
		id=PID, max_hops=30, ip_address_resolved = None):
	#interval=0.05, timeout=0.10,
	#timeout=2
	#count=2, interval=0.05, timeout=0.20, id=PID, max_hops=30

	# interval=0.05 ->0.5, timeout=0.01 -> 0.1
	
	results = {}
	# We perform a DNS lookup if a hostname or an FQDN is passed in
	# parameters.
	if is_hostname(address):
		try:
			ip_address = resolve(address)[0] if ip_address_resolved is None else ip_address_resolved
		except:
			print(f"The name '{address}' cannot be resolved")
			return None
	else:
		ip_address = address
	results[address] = {}
	# A payload of 56 bytes is used by default. You can modify it using
	# the 'payload_size' parameter of your ICMP request.
	payload_size = 56
	print_interval = 500 if interval == 0.05 else interval
	if timeout < 1: 
		timeout *= 10
		print_timeout = str(timeout*10)
	elif timeout < 0.1: 
		timeout *= 100
		#print_timeout = str({:.}).format(timeout*100)
		print_timeout = '{d}'.format(timeout*100)
	#timeout= '{:.0n}'.format(timeout)
	#timeout= '{:.2%}'.format(timeout)
	#print_timeout = 1 if timeout == 0.01 else timeout
	print('timeout', timeout)
	

	print(f'{utility.get_username()}@{utility.get_pcname()} {utility.get_currentdirectory()}$ traceroute -m {max_hops} -w {print_timeout} -z {print_interval} {address} {payload_size}')
	print(f'traceroute to {address} ({ip_address}), '
		  f'{max_hops} hops max, {payload_size} byte packets')
	results[address]['traceroute']=[]
	results[address]['parameters']={"address":address, "ip_address":ip_address,"max_hops":max_hops, "timeout":print_timeout, "interval":print_interval, "payload_size":payload_size, "username":utility.get_username(), "pcname":utility.get_pcname(), "currentdirectory":utility.get_currentdirectory()}
	#results[address]['traceroute'].append(f'Traceroute to {address} ({ip_address}), {max_hops} hops max, {payload_size} byte packets')

	# We detect the socket to use from the specified IP address
	if is_ipv6_address(ip_address):
		sock = ICMPv6Socket()
	else:
		sock = ICMPv4Socket()

	ttl = 1
	host_reached = False
	network_issue = False

	while not host_reached and ttl <= max_hops:
		for sequence in range(count):
			# We create an ICMP request
			request = ICMPRequest(
				destination=ip_address,
				id=id,
				sequence=sequence,
				ttl=ttl,
				payload_size=payload_size)

			try:
				# We send the request
				sock.send(request)

				# We are awaiting receipt of an ICMP reply
				reply = sock.receive(request, timeout)

				# We received a reply
				# We display some information
				source_name = getfqdn(reply.source)
				if ttl<10:
					print(f' {ttl:<2} {source_name}  ({reply.source})  ', end='')
				else:
					print(f'{ttl:<2}  {source_name}  ({reply.source})  ', end='')
				# We throw an exception if it is an ICMP error message
				reply.raise_for_status()

				# We reached the destination host
				# We calculate the round-trip time and we display it
				round_trip_time = (reply.time - request.time) * 1000
				print(round(round_trip_time, 3), 'ms')
				results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))+' ms'])

				# We can stop the search
				host_reached = True
				break

			except TimeExceeded as err:
				# An ICMP Time Exceeded message has been received
				# The message was probably generated by an intermediate
				# gateway
				reply = err.reply

				# We calculate the round-trip time and we display it
				round_trip_time = (reply.time - request.time) * 1000
				print(round(round_trip_time, 3), 'ms')
				#results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))'+' ms'])
				results[address]['traceroute'].append([reply.source,source_name,str(round(round_trip_time, 3))+' ms'])
				sleep(interval)
				break

			except TimeoutExceeded:
				# The timeout has been reached and no host or gateway
				# has responded after multiple attempts
				if sequence >= count - 1:
					#print(f'{ttl:<2}  * * *')
					if ttl<10:
						print(f' {ttl:<2} * * *')
					else:
						print(f'{ttl:<2}  * * *')
					results[address]['traceroute'].append(None)
					network_issue = True
			except ICMPLibError:
				# Other errors are ignored
				pass

		ttl += 1
	print("Completed.")
	if host_reached: print(f"Host {ip_address} ({address}) reached"); 
	else: print("Host did not reach")
	results[address]['statistics'] = {'completed':True}
	results[address]['statistics']['host_reached'] = host_reached
	results[address]['statistics']['network_issue'] = network_issue
	
	return results

# This function supports both FQDNs and IP addresses. See the 'resolve'
# function for details.
if __name__ == '__main__':
	import sys
	import json
	if len(sys.argv) != 2:
		print('usage: %s example.com' % sys.argv[0])
		host='fbi.gov'
		hosts = [
			# 'www.whitehouse.gov',
			# 'www.facebook.com',
			# 'www.amzn.com',
			# 'amazon.com',
			'us2723.nordvpn.com',
			'ch217.nordvpn.com',
			'jp590.nordvpn.com',
			'za110.nordvpn.com',
			'fbi.gov',
			'www.ic3.gov',
			'ic3.gov']
		for host in hosts:
			#print(json.dumps(verbose_traceroute(host)), indent=4)
			print(verbose_traceroute(host))

	else:
		host=str(sys.argv[1])
		print(sys.argv[1])
	result=verbose_traceroute(host)
	print('result',result)
	# result=verbose_traceroute("ic3.gov")
	# print('result',result)

	